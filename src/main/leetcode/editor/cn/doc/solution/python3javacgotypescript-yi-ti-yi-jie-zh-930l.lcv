**æ–¹æ³•ä¸€ï¼šçŠ¶æ€åŽ‹ç¼© + æ•°ä½ DP**

é¢˜ç›®è¦æ±‚ç»Ÿè®¡ $[1,..n]$ ä¸­è‡³å°‘æœ‰ä¸€ä½é‡å¤çš„æ•°å­—çš„ä¸ªæ•°ï¼Œæˆ‘ä»¬å¯ä»¥æ¢ä¸€ç§æ€è·¯ï¼Œç”¨ä¸€ä¸ªå‡½æ•° $f(n)$ ç»Ÿè®¡ $[1,..n]$ ä¸­æ²¡æœ‰é‡å¤æ•°å­—çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $n - f(n)$ã€‚

å¦å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶æ•°æ¥è®°å½•æ•°å­—ä¸­å‡ºçŽ°è¿‡çš„æ•°å­—ï¼Œæ¯”å¦‚æ•°å­—ä¸­å‡ºçŽ°äº† $1$, $2$, $4$ï¼Œé‚£ä¹ˆå¯¹åº”çš„äºŒè¿›åˆ¶æ•°å°±æ˜¯ $\underline{1}0\underline{1}\underline{1}0$ã€‚

æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨è®°å¿†åŒ–æœç´¢æ¥å®žçŽ°æ•°ä½ DPã€‚ä»Žèµ·ç‚¹å‘ä¸‹æœç´¢ï¼Œåˆ°æœ€åº•å±‚å¾—åˆ°æ–¹æ¡ˆæ•°ï¼Œä¸€å±‚å±‚å‘ä¸Šè¿”å›žç­”æ¡ˆå¹¶ç´¯åŠ ï¼Œæœ€åŽä»Žæœç´¢èµ·ç‚¹å¾—åˆ°æœ€ç»ˆçš„ç­”æ¡ˆã€‚

åŸºæœ¬æ­¥éª¤å¦‚ä¸‹ï¼š

1. å°†æ•°å­— $n$ è½¬ä¸ºæ•´åž‹æ•°ç»„ $nums$ï¼Œå…¶ä¸­ $nums[0]$ ä¸ºæœ€ä½Žä½ï¼Œè€Œ $nums[i]$ ä¸ºæœ€é«˜ä½ï¼›
2. æ ¹æ®é¢˜ç›®ä¿¡æ¯ï¼Œè®¾è®¡å‡½æ•° $dfs()$ï¼Œå¯¹äºŽæœ¬é¢˜ï¼Œæˆ‘ä»¬å®šä¹‰ $dfs(pos, mask, lead, limit)$ï¼Œå…¶ä¸­ï¼š

- å‚æ•° $pos$ è¡¨ç¤ºå½“å‰æœç´¢åˆ°çš„æ•°å­—çš„ä½æ•°ï¼Œä»Žæœ«ä½æˆ–è€…ç¬¬ä¸€ä½å¼€å§‹ï¼Œä¸€èˆ¬æ ¹æ®é¢˜ç›®çš„æ•°å­—æž„é€ æ€§è´¨æ¥é€‰æ‹©é¡ºåºã€‚å¯¹äºŽæœ¬é¢˜ï¼Œæˆ‘ä»¬é€‰æ‹©ä»Žé«˜ä½å¼€å§‹ï¼Œå› æ­¤ï¼Œ$pos$ çš„åˆå§‹å€¼ä¸ºæ•°å­—çš„é«˜ä½ä¸‹æ ‡ï¼›
- å‚æ•° $mask$ è¡¨ç¤ºå½“å‰æ•°å­—ä¸­å‡ºçŽ°è¿‡çš„æ•°å­—ï¼›
- å‚æ•° $lead$ è¡¨ç¤ºå½“å‰æ•°å­—æ˜¯å¦ä»…åŒ…å«å‰å¯¼é›¶ï¼›
- å‚æ•° $limit$ è¡¨ç¤ºå½“å‰å¯å¡«çš„æ•°å­—çš„é™åˆ¶ï¼Œå¦‚æžœæ— é™åˆ¶ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹© $i \in [0,1,..9]$ï¼Œå¦åˆ™ï¼Œåªèƒ½é€‰æ‹© $i \in [0,..nums[pos]]$ã€‚å¦‚æžœ $limit$ ä¸º `true` ä¸”å·²ç»å–åˆ°äº†èƒ½å–åˆ°çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ª $limit$ åŒæ ·ä¸º `true`ï¼›å¦‚æžœ $limit$ ä¸º `true` ä½†æ˜¯è¿˜æ²¡æœ‰å–åˆ°æœ€å¤§å€¼ï¼Œæˆ–è€… $limit$ ä¸º `false`ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ª $limit$ ä¸º `false`ã€‚

ç­”æ¡ˆä¸º $dfs(0, 0, true, true)$ã€‚

å…³äºŽå‡½æ•°çš„å®žçŽ°ç»†èŠ‚ï¼Œå¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ã€‚

* [sol1-Python3]

```python
class Solution:
    def numDupDigitsAtMostN(self, n: int) -> int:
        return n - self.f(n)

    def f(self, n: int) -> int:
        @cache
        def dfs(pos: int, mask: int, lead: bool, limit: bool) -> int:
            if pos < 0:
                return int(lead) ^ 1
            up = nums[pos] if limit else 9
            ans = 0
            for i in range(up + 1):
                if mask >> i & 1:
                    continue
                if i == 0 and lead:
                    ans += dfs(pos - 1, mask, lead, limit and i == up)
                else:
                    ans += dfs(pos - 1, mask | 1 << i, False, limit and i == up)
            return ans

        nums = []
        while n:
            nums.append(n % 10)
            n //= 10
        return dfs(len(nums) - 1, 0, True, True)
```

* [sol1-Java]

```java
class Solution {
    private int[] nums = new int[11];
    private Integer[][] dp = new Integer[11][1 << 11];

    public int numDupDigitsAtMostN(int n) {
        return n - f(n);
    }

    private int f(int n) {
        int i = -1;
        for (; n > 0; n /= 10) {
            nums[++i] = n % 10;
        }
        return dfs(i, 0, true, true);
    }

    private int dfs(int pos, int mask, boolean lead, boolean limit) {
        if (pos < 0) {
            return lead ? 0 : 1;
        }
        if (!lead && !limit && dp[pos][mask] != null) {
            return dp[pos][mask];
        }
        int ans = 0;
        int up = limit ? nums[pos] : 9;
        for (int i = 0; i <= up; ++i) {
            if ((mask >> i & 1) == 1) {
                continue;
            }
            if (i == 0 && lead) {
                ans += dfs(pos - 1, mask, lead, limit && i == up);
            } else {
                ans += dfs(pos - 1, mask | 1 << i, false, limit && i == up);
            }
        }
        if (!lead && !limit) {
            dp[pos][mask] = ans;
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int numDupDigitsAtMostN(int n) {
        return n - f(n);
    }

private:
    int nums[11];
    int dp[11][1 << 11];

    int f(int n) {
        memset(dp, -1, sizeof(dp));
        int i = -1;
        for (; n; n /= 10) {
            nums[++i] = n % 10;
        }
        return dfs(i, 0, true, true);
    }

    int dfs(int pos, int mask, bool lead, bool limit) {
        if (pos < 0) {
            return lead ? 0 : 1;
        }
        if (!lead && !limit && dp[pos][mask] != -1) {
            return dp[pos][mask];
        }
        int up = limit ? nums[pos] : 9;
        int ans = 0;
        for (int i = 0; i <= up; ++i) {
            if (mask >> i & 1) {
                continue;
            }
            if (i == 0 && lead) {
                ans += dfs(pos - 1, mask, lead, limit && i == up);
            } else {
                ans += dfs(pos - 1, mask | 1 << i, false, limit && i == up);
            }
        }
        if (!lead && !limit) {
            dp[pos][mask] = ans;
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func numDupDigitsAtMostN(n int) int {
	return n - f(n)
}

func f(n int) int {
	nums := []int{}
	for ; n > 0; n /= 10 {
		nums = append(nums, n%10)
	}
	dp := [11][1 << 11]int{}
	for i := range dp {
		for j := range dp[i] {
			dp[i][j] = -1
		}
	}
	var dfs func(int, int, bool, bool) int
	dfs = func(pos int, mask int, lead bool, limit bool) int {
		if pos < 0 {
			if lead {
				return 0
			}
			return 1
		}
		if !lead && !limit && dp[pos][mask] != -1 {
			return dp[pos][mask]
		}
		up := 9
		if limit {
			up = nums[pos]
		}
		ans := 0
		for i := 0; i <= up; i++ {
			if mask>>i&1 == 1 {
				continue
			}
			if i == 0 && lead {
				ans += dfs(pos-1, mask, lead, limit && i == up)
			} else {
				ans += dfs(pos-1, mask|1<<i, false, limit && i == up)
			}
		}
		if !lead && !limit {
			dp[pos][mask] = ans
		}
		return ans
	}
	return dfs(len(nums)-1, 0, true, true)
}
```

* [sol1-TypeScript]

```ts
function numDupDigitsAtMostN(n: number): number {
    return n - f(n);
}

function f(n: number): number {
    const nums: number[] = [];
    let i = -1;
    for (; n; n = Math.floor(n / 10)) {
        nums[++i] = n % 10;
    }
    const dp = Array.from({ length: 11 }, () => Array(1 << 11).fill(-1));
    const dfs = (pos: number, mask: number, lead: boolean, limit: boolean): number => {
        if (pos < 0) {
            return lead ? 0 : 1;
        }
        if (!lead && !limit && dp[pos][mask] !== -1) {
            return dp[pos][mask];
        }
        const up = limit ? nums[pos] : 9;
        let ans = 0;
        for (let i = 0; i <= up; ++i) {
            if ((mask >> i) & 1) {
                continue;
            }
            if (lead && i === 0) {
                ans += dfs(pos - 1, mask, lead, limit && i === up);
            } else {
                ans += dfs(pos - 1, mask | (1 << i), false, limit && i === up);
            }
        }
        if (!lead && !limit) {
            dp[pos][mask] = ans;
        }
        return ans;
    };
    return dfs(i, 0, true, true);
}
```

æ—¶é—´å¤æ‚åº¦ $O(m \times 2^m \times 10)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m \times 2^m)$ã€‚å…¶ä¸­ $m$ ä¸ºæ•°å­— $n$ çš„ä½æ•°ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
